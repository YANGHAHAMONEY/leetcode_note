## 30. 串联所有单词的子串  
**难度**：困难  

#### 相关标签  
`premium lock icon`  

#### 相关企业  

#### 题目描述  
给定一个字符串 `s` 和一个字符串数组 `words`。`words` 中所有字符串 **长度相同**。  

`s` 中的 **串联子串** 是指一个包含 `words` 中所有字符串以任意顺序排列连接起来的子串。  

例如，如果 `words = ["ab","cd","ef"]`，那么 `"abcdef"`、`"abefcd"`、`"cdabef"`、`"cdefab"`、`"efabcd"` 和 `"efcdab"` 都是串联子串。`"acdbef"` 不是串联子串，因为它不是任何 `words` 排列的连接。  

返回所有串联子串在 `s` 中的开始索引。你可以以 **任意顺序** 返回答案。  

#### 示例 1  

**输入**：`s = "barfoothefoobarman"`, `words = ["foo","bar"]`  
**输出**：`[0,9]`  
**解释**：  
- 因为 `words.length == 2` 且 `words[i].length == 3`，所以串联子串的长度必须为 `6`。  
- 子串 `"barfoo"` 开始位置是 `0`，它是 `words` 以 `["bar","foo"]` 顺序排列的连接。  
- 子串 `"foobar"` 开始位置是 `9`，它是 `words` 以 `["foo","bar"]` 顺序排列的连接。  
- 输出顺序无关紧要，返回 `[9,0]` 也是可以的。  

#### 示例 2  

**输入**：`s = "wordgoodgoodgoodbestword"`, `words = ["word","good","best","word"]`  
**输出**：`[]`  
**解释**：  
- 因为 `words.length == 4` 且 `words[i].length == 4`，所以串联子串的长度必须为 `16`。  
- `s` 中没有长度为 `16` 的子串等于 `words` 的任何顺序排列的连接，因此返回空数组。  

#### 示例 3  

**输入**：`s = "barfoofoobarthefoobarman"`, `words = ["bar","foo","the"]`  
**输出**：`[6,9,12]`  
**解释**：  
- 因为 `words.length == 3` 且 `words[i].length == 3`，所以串联子串的长度必须为 `9`。  
- 子串 `"foobarthe"` 开始位置是 `6`，它是 `words` 以 `["foo","bar","the"]` 顺序排列的连接。  
- 子串 `"barthefoo"` 开始位置是 `9`，它是 `words` 以 `["bar","the","foo"]` 顺序排列的连接。  
- 子串 `"thefoobar"` 开始位置是 `12`，它是 `words` 以 `["the","foo","bar"]` 顺序排列的连接。  

#### 提示  
- `1 <= s.length <= 10^4`  
- `1 <= words.length <= 5000`  
- `1 <= words[i].length <= 30`  
- `words[i]` 和 `s` 由小写英文字母组成  

#### 补充说明  
- 本题需要高效地检查 `s` 中所有可能的子串是否由 `words` 的某种排列组成。  
- 常见解法：**滑动窗口 + 哈希表**（统计 `words` 的词频，并在 `s` 中匹配）。  
- 时间复杂度优化是关键，避免暴力匹配。