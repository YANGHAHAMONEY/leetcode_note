### 题目：10. 正则表达式匹配

#### 难度：困难

#### 题目描述：
给定一个字符串 `s` 和一个正则表达式模式 `p`，实现支持 `'.'` 和 `'*'` 的正则表达式匹配。匹配需覆盖整个字符串 `s`。

**规则**：
- `'.'` 匹配任意单个字符。
- `'*'` 匹配零个或多个前面的元素。

---

#### 示例：

**示例 1**：
- 输入：`s = "aa"`, `p = "a"`
- 输出：`false`
- 解释：`"a"` 无法匹配 `"aa"`。

**示例 2**：
- 输入：`s = "aa"`, `p = "a*"`
- 输出：`true`
- 解释：`'*'` 表示 `'a'` 可重复零次或多次，因此 `"aa"` 匹配。

**示例 3**：
- 输入：`s = "ab"`, `p = ".*"`
- 输出：`true`
- 解释：`".*"` 表示任意字符（`'.'`）可重复零次或多次（`'*'`），因此 `"ab"` 匹配。

---

#### 提示：
1. `1 <= s.length <= 20`
2. `1 <= p.length <= 20`
3. `s` 只含小写字母 `a-z`。
4. `p` 只含小写字母 `a-z`、`'.'` 和 `'*'`。
5. 保证每次出现 `'*'` 时，前面都匹配到有效字符。

---

#### 解题思路：
1. **动态规划（DP）**：
   - 定义 `dp[i][j]` 表示 `s[0..i-1]` 和 `p[0..j-1]` 是否匹配。
   - 状态转移：
     - 如果 `p[j-1] != '*'`：
       - `dp[i][j] = dp[i-1][j-1]`，且 `s[i-1] == p[j-1]` 或 `p[j-1] == '.'`。
     - 如果 `p[j-1] == '*'`：
       - 匹配零个字符：`dp[i][j] = dp[i][j-2]`。
       - 匹配一个或多个字符：`dp[i][j] = dp[i-1][j]`，且 `s[i-1] == p[j-2]` 或 `p[j-2] == '.'`。
   - 初始化：
     - `dp[0][0] = True`（空字符串匹配空模式）。
     - `dp[0][j]` 需处理 `p` 的前 `j` 个字符是否能匹配空字符串（如 `"a*b*"`）。
   - 时间复杂度：`O(mn)`，空间复杂度：`O(mn)`（可优化为 `O(n)`）。

2. **递归 + 记忆化**：
   - 递归检查每种可能的匹配情况，使用记忆化存储中间结果。
   - 时间复杂度：`O(mn)`，空间复杂度：`O(mn)`。

---

#### 伪代码（动态规划）：
```
function isMatch(s, p):
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    for j in range(1, n + 1):
        if p[j-1] == '*':
            dp[0][j] = dp[0][j-2]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j-1] == '.' or p[j-1] == s[i-1]:
                dp[i][j] = dp[i-1][j-1]
            elif p[j-1] == '*':
                dp[i][j] = dp[i][j-2]
                if p[j-2] == '.' or p[j-2] == s[i-1]:
                    dp[i][j] |= dp[i-1][j]
    return dp[m][n]
```

---

#### 注意事项：
- 初始化时需处理 `p` 的前缀 `'*'` 能否匹配空字符串。
- `'*'` 的状态转移需考虑匹配零个或多个字符的情况。
- 边界条件：空字符串和空模式的匹配。

---

#### 代码实现（Python，动态规划）：
```python
def isMatch(s: str, p: str) -> bool:
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    for j in range(1, n + 1):
        if p[j-1] == '*':
            dp[0][j] = dp[0][j-2]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j-1] == '.' or p[j-1] == s[i-1]:
                dp[i][j] = dp[i-1][j-1]
            elif p[j-1] == '*':
                dp[i][j] = dp[i][j-2]
                if p[j-2] == '.' or p[j-2] == s[i-1]:
                    dp[i][j] |= dp[i-1][j]
    return dp[m][n]
```

---

#### 复杂度分析：
- **时间复杂度**：`O(mn)`，其中 `m` 和 `n` 分别是 `s` 和 `p` 的长度。
- **空间复杂度**：`O(mn)`（可优化为 `O(n)`）。

---

#### 其他解法（递归 + 记忆化）：
```python
from functools import lru_cache

def isMatch(s: str, p: str) -> bool:
    @lru_cache(None)
    def dfs(i, j):
        if j == len(p):
            return i == len(s)
        first_match = i < len(s) and (p[j] == '.' or p[j] == s[i])
        if j + 1 < len(p) and p[j+1] == '*':
            return dfs(i, j+2) or (first_match and dfs(i+1, j))
        else:
            return first_match and dfs(i+1, j+1)
    return dfs(0, 0)
```