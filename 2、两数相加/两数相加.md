### 题目：2. 两数相加

#### 难度：中等

#### 题目描述：
给定两个**非空**的链表，表示两个非负的整数。链表中每个节点存储一位数字，且数字按照**逆序**方式排列（即链表的第一个节点表示数字的个位）。请将这两个数相加，并以相同形式的链表返回它们的和。

**假设条件**：
- 除了数字 `0` 之外，这两个数都不会以 `0` 开头。
- 链表中的节点数范围在 `[1, 100]` 内。
- 每个节点的值满足 `0 <= Node.val <= 9`。
- 题目数据保证列表表示的数字不含前导零。

---

#### 示例：

**示例 1**：
- 输入：`l1 = [2,4,3]`, `l2 = [5,6,4]`
- 输出：`[7,0,8]`
- 解释：`342 + 465 = 807`（链表 `[2,4,3]` 表示数字 `342`，链表 `[5,6,4]` 表示数字 `465`，和为 `807`，逆序存储为 `[7,0,8]`）。

**示例 2**：
- 输入：`l1 = [0]`, `l2 = [0]`
- 输出：`[0]`
- 解释：`0 + 0 = 0`。

**示例 3**：
- 输入：`l1 = [9,9,9,9,9,9,9]`, `l2 = [9,9,9,9]`
- 输出：`[8,9,9,9,0,0,0,1]`
- 解释：`9999999 + 9999 = 10009998`，逆序存储为 `[8,9,9,9,0,0,0,1]`。

---

#### 提示：
1. 链表的遍历和数字的逐位相加是解决问题的关键。
2. 注意处理进位问题（例如：`5 + 7 = 12`，当前位写 `2`，进位 `1`）。
3. 如果两个链表长度不同，可以认为短链表的后面有若干个 `0` 节点。
4. 遍历结束后，如果仍有进位（如 `999 + 1`），需要在结果链表中添加一个值为 `1` 的新节点。

---

#### 解题思路（伪代码）：
1. 初始化一个哑节点（dummy node）作为结果链表的头部，并初始化进位 `carry = 0`。
2. 同时遍历 `l1` 和 `l2`，直到两者都为空：
   - 计算当前位的和：`sum = l1_val + l2_val + carry`。
   - 更新进位：`carry = sum // 10`。
   - 创建新节点，值为 `sum % 10`，并将其链接到结果链表。
3. 如果遍历结束后 `carry > 0`，添加一个值为 `carry` 的新节点。
4. 返回哑节点的下一个节点（即结果链表的实际头部）。

---

#### 注意事项：
- 链表节点的操作需要小心指针的移动和空值判断。
- 逆序存储的特性使得问题更简单（直接从个位开始相加），无需反转链表。