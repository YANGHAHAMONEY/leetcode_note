### 题目：3. 无重复字符的最长子串

#### 难度：中等

#### 题目描述：
给定一个字符串 `s`，请找出其中不含有重复字符的**最长子串**的长度。

**子串**：字符串中连续的字符序列（必须连续）。
**子序列**：字符串中不连续的字符序列（可以不连续）。

---

#### 示例：

**示例 1**：
- 输入：`s = "abcabcbb"`
- 输出：`3`
- 解释：最长无重复字符的子串是 `"abc"`，长度为 `3`。

**示例 2**：
- 输入：`s = "bbbbb"`
- 输出：`1`
- 解释：最长无重复字符的子串是 `"b"`，长度为 `1`。

**示例 3**：
- 输入：`s = "pwwkew"`
- 输出：`3`
- 解释：最长无重复字符的子串是 `"wke"`，长度为 `3`。注意 `"pwke"` 是子序列而非子串。

---

#### 提示：
1. 字符串 `s` 的长度范围：`0 <= s.length <= 5 * 10^4`。
2. `s` 由英文字母、数字、符号和空格组成。

---

#### 解题思路：
1. **滑动窗口（Sliding Window）**：
   - 使用双指针 `left` 和 `right` 表示当前窗口的左右边界。
   - 维护一个哈希集合 `seen` 记录当前窗口中的字符。
   - 遍历字符串：
     - 如果 `s[right]` 不在 `seen` 中，则加入 `seen`，并更新最大长度 `max_len`。
     - 如果 `s[right]` 在 `seen` 中，则移动 `left` 指针，直到 `s[right]` 不再重复。
   - 时间复杂度：`O(n)`（每个字符最多被访问两次）。
   - 空间复杂度：`O(min(m, n))`（`m` 是字符集大小）。

2. **优化滑动窗口**：
   - 直接记录字符的最新位置，遇到重复时直接跳转 `left` 到 `max(left, seen[s[right]] + 1)`。
   - 避免逐个移动 `left`，提升效率。

---

#### 伪代码：
```
function lengthOfLongestSubstring(s):
    seen = {}  # 记录字符的最新位置
    left = 0
    max_len = 0
    for right in range(len(s)):
        if s[right] in seen:
            left = max(left, seen[s[right]] + 1)
        seen[s[right]] = right
        max_len = max(max_len, right - left + 1)
    return max_len
```

---

#### 注意事项：
- 空字符串直接返回 `0`。
- 哈希集合或哈希表的更新需要及时。
- 子串必须连续，子序列可以不连续（如 `"pwke"` 是子序列而非子串）。

---

#### 代码实现（Python）：
```python
def lengthOfLongestSubstring(s: str) -> int:
    seen = {}
    left = 0
    max_len = 0
    for right in range(len(s)):
        if s[right] in seen:
            left = max(left, seen[s[class Solution(object):
    def lengthOfLongestSubstring(self, s):
        left, right = 0, 0
        res = 0
        if len(s) == 0:
            return 0
        if s.count(s[0]) == len(s):
            return 1
        if len(set(s)) == len(s):
            return len(s)
        while right < len(s):
            if s[right] not in s[left:right]:
                right += 1
                res = max(res, right - left)
            else:
                while s[right] in s[left:right]:
                    left += 1
        return resright]] + 1)
        seen[s[right]] = right
        max_len = max(max_len, right - left + 1)
    return max_len
```

---

#### 复杂度分析：
- **时间复杂度**：`O(n)`，每个字符最多被访问两次。
- **空间复杂度**：`O(min(m, n))`，`m` 是字符集大小（ASCII 最多 `128` 或 `256`）。