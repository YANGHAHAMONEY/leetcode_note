### 题目：4. 寻找两个正序数组的中位数

#### 难度：困难

#### 题目描述：
给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`，请找出并返回这两个正序数组的**中位数**。要求算法的时间复杂度为 `O(log (m+n))`。

**中位数**：
- 如果合并后的数组长度为奇数，中位数是中间的那个数。
- 如果合并后的数组长度为偶数，中位数是中间两个数的平均值。

---

#### 示例：

**示例 1**：
- 输入：`nums1 = [1,3]`, `nums2 = [2]`
- 输出：`2.00000`
- 解释：合并数组为 `[1,2,3]`，中位数是 `2`。

**示例 2**：
- 输入：`nums1 = [1,2]`, `nums2 = [3,4]`
- 输出：`2.50000`
- 解释：合并数组为 `[1,2,3,4]`，中位数是 `(2 + 3) / 2 = 2.5`。

---

#### 提示：
1. `nums1.length == m`
2. `nums2.length == n`
3. `0 <= m <= 1000`
4. `0 <= n <= 1000`
5. `1 <= m + n <= 2000`
6. `-10^6 <= nums1[i], nums2[i] <= 10^6`

---

#### 解题思路：
1. **直接合并排序法**（不满足时间复杂度要求）：
   - 合并两个数组并排序，直接取中位数。
   - 时间复杂度：`O((m+n) log (m+n))`（不满足题目要求）。

2. **双指针归并法**（不满足时间复杂度要求）：
   - 使用双指针合并两个有序数组，然后取中位数。
   - 时间复杂度：`O(m+n)`（不满足题目要求）。

3. **二分查找法**（满足 `O(log (m+n))`）：
   - 核心思想：将问题转化为寻找两个有序数组的第 `k` 小的数。
   - 每次排除 `k/2` 个元素，逐步逼近中位数。
   - 具体步骤：
     - 假设 `nums1` 和 `nums2` 的中位数分别在 `i` 和 `j` 的位置。
     - 比较 `nums1[i]` 和 `nums2[j]`，排除较小的一部分。
     - 递归或迭代处理剩余部分。

---

#### 伪代码：
```
function findMedianSortedArrays(nums1, nums2):
    m, n = len(nums1), len(nums2)
    if m > n:
        nums1, nums2, m, n = nums2, nums1, n, m  # 确保 nums1 是较短的数组
    left, right = 0, m
    while left <= right:
        i = (left + right) // 2  # nums1 的分割点
        j = (m + n + 1) // 2 - i  # nums2 的分割点
        if i < m and nums2[j-1] > nums1[i]:
            left = i + 1  # nums1 的分割点需要右移
        elif i > 0 and nums1[i-1] > nums2[j]:
            right = i - 1  # nums1 的分割点需要左移
        else:
            if i == 0:
                max_left = nums2[j-1]
            elif j == 0:
                max_left = nums1[i-1]
            else:
                max_left = max(nums1[i-1], nums2[j-1])
            if (m + n) % 2 == 1:
                return max_left
            if i == m:
                min_right = nums2[j]
            elif j == n:
                min_right = nums1[i]
            else:
                min_right = min(nums1[i], nums2[j])
            return (max_left + min_right) / 2
```

---

#### 注意事项：
- 确保 `nums1` 是较短的数组，减少计算量。
- 处理边界条件（如 `i=0` 或 `j=0`）。
- 奇数和偶数长度的中位数计算方式不同。

---

#### 代码实现（Python）：
```python
def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    m, n = len(nums1), len(nums2)
    left, right = 0, m
    while left <= right:
        i = (left + right) // 2
        j = (m + n + 1) // 2 - i
        if i < m and nums2[j-1] > nums1[i]:
            left = i + 1
        elif i > 0 and nums1[i-1] > nums2[j]:
            right = i - 1
        else:
            if i == 0:
                max_left = nums2[j-1]
            elif j == 0:
                max_left = nums1[i-1]
            else:
                max_left = max(nums1[i-1], nums2[j-1])
            if (m + n) % 2 == 1:
                return max_left
            if i == m:
                min_right = nums2[j]
            elif j == n:
                min_right = nums1[i]
            else:
                min_right = min(nums1[i], nums2[j])
            return (max_left + min_right) / 2
```

---

#### 复杂度分析：
- **时间复杂度**：`O(log(min(m, n)))`，因为每次排除一半的元素。
- **空间复杂度**：`O(1)`，仅使用常数空间。