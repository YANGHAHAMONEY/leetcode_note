### 题目：5. 最长回文子串

#### 难度：中等

#### 题目描述：
给定一个字符串 `s`，找到 `s` 中最长的**回文子串**。你可以假设 `s` 的最大长度为 `1000`，且仅由数字和英文字母组成。

**回文子串**：正读和反读都相同的字符串（如 `"aba"`、`"bb"`）。

---

#### 示例：

**示例 1**：
- 输入：`s = "babad"`
- 输出：`"bab"` 或 `"aba"`
- 解释：`"bab"` 和 `"aba"` 都是最长的回文子串。

**示例 2**：
- 输入：`s = "cbbd"`
- 输出：`"bb"`
- 解释：`"bb"` 是最长的回文子串。

---

#### 提示：
1. `1 <= s.length <= 1000`
2. `s` 仅由数字和英文字母组成。

---

#### 解题思路：
1. **中心扩展法**：
   - 遍历字符串，以每个字符为中心向两边扩展，寻找最长回文子串。
   - 需要考虑奇数长度（如 `"aba"`）和偶数长度（如 `"bb"`）的回文。
   - 时间复杂度：`O(n^2)`（两层循环）。
   - 空间复杂度：`O(1)`。

2. **动态规划法**：
   - 定义 `dp[i][j]` 表示 `s[i..j]` 是否为回文。
   - 状态转移方程：
     - 如果 `s[i] == s[j]` 且 `dp[i+1][j-1]` 为 `True`，则 `dp[i][j] = True`。
     - 边界条件：`dp[i][i] = True`（单个字符），`dp[i][i+1] = (s[i] == s[i+1])`（两个字符）。
   - 时间复杂度：`O(n^2)`。
   - 空间复杂度：`O(n^2)`。

3. **Manacher 算法**：
   - 线性时间复杂度的算法，但实现较复杂。
   - 时间复杂度：`O(n)`。
   - 空间复杂度：`O(n)`。

---

#### 伪代码（中心扩展法）：
```
function longestPalindrome(s):
    start, end = 0, 0
    for i in range(len(s)):
        len1 = expandAroundCenter(s, i, i)      # 奇数长度
        len2 = expandAroundCenter(s, i, i+1)    # 偶数长度
        max_len = max(len1, len2)
        if max_len > end - start:
            start = i - (max_len - 1) // 2
            end = i + max_len // 2
    return s[start:end+1]

function expandAroundCenter(s, left, right):
    while left >= 0 and right < len(s) and s[left] == s[right]:
        left -= 1
        right += 1
    return right - left - 1
```

---

#### 注意事项：
- 中心扩展法需要处理奇数和偶数长度的回文。
- 动态规划法需要填充二维表格，空间开销较大。
- 边界条件（如 `s` 为空或长度为 `1`）直接返回 `s`。

---

#### 代码实现（Python，中心扩展法）：
```python
def longestPalindrome(s: str) -> str:
    def expandAroundCenter(left: int, right: int) -> int:
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return right - left - 1

    start, end = 0, 0
    for i in range(len(s)):
        len1 = expandAroundCenter(i, i)
        len2 = expandAroundCenter(i, i + 1)
        max_len = max(len1, len2)
        if max_len > end - start:
            start = i - (max_len - 1) // 2
            end = i + max_len // 2
    return s[start:end + 1]
```

---

#### 复杂度分析：
- **时间复杂度**：`O(n^2)`，两层循环。
- **空间复杂度**：`O(1)`，仅使用常数空间。

---

#### 其他解法（动态规划）：
```python
def longestPalindrome(s: str) -> str:
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    ans = ""
    for l in range(n):
        for i in range(n - l):
            j = i + l
            if l == 0:
                dp[i][j] = True
            elif l == 1:
                dp[i][j] = (s[i] == s[j])
            else:
                dp[i][j] = (s[i] == s[j] and dp[i + 1][j - 1])
            if dp[i][j] and l + 1 > len(ans):
                ans = s[i:j + 1]
    return ans
```