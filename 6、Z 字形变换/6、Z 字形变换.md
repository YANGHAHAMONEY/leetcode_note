### 题目：6. Z 字形变换

#### 难度：中等

#### 题目描述：
给定一个字符串 `s` 和一个行数 `numRows`，将字符串按照从上到下、从左到右的 Z 字形排列后，再按行读取生成新的字符串。

**Z 字形排列规则**：
- 从第 `0` 行开始，向下填充到 `numRows - 1` 行。
- 然后从 `numRows - 1` 行开始，向上填充到 `0` 行。
- 重复上述过程，直到字符串结束。

**示例**：
- 输入：`s = "PAYPALISHIRING"`, `numRows = 3`
- 输出：`"PAHNAPLSIIGYIR"`
- 解释：
  ```
  P   A   H   N
  A P L S I I G
  Y   I   R
  ```

---

#### 示例：

**示例 1**：
- 输入：`s = "PAYPALISHIRING"`, `numRows = 3`
- 输出：`"PAHNAPLSIIGYIR"`

**示例 2**：
- 输入：`s = "PAYPALISHIRING"`, `numRows = 4`
- 输出：`"PINALSIGYAHRPI"`
- 解释：
  ```
  P     I    N
  A   L S  I G
  Y A   H R
  P     I
  ```

**示例 3**：
- 输入：`s = "A"`, `numRows = 1`
- 输出：`"A"`

---

#### 提示：
1. `1 <= s.length <= 1000`
2. `s` 由英文字母（小写和大写）、`','` 和 `'.'` 组成。
3. `1 <= numRows <= 1000`

---

#### 解题思路：
1. **模拟法**：
   - 初始化 `numRows` 个空字符串，表示每一行的字符。
   - 遍历字符串 `s`，按照 Z 字形规则将字符填充到对应行。
   - 最后按行拼接所有字符。

2. **数学规律法**：
   - 观察 Z 字形排列的规律，直接计算每个字符所在的行。
   - 适用于大规模数据，但实现较复杂。

---

#### 伪代码（模拟法）：
```
function convert(s, numRows):
    if numRows == 1:
        return s
    rows = [""] * numRows
    current_row = 0
    going_down = False
    for c in s:
        rows[current_row] += c
        if current_row == 0 or current_row == numRows - 1:
            going_down = not going_down
        current_row += 1 if going_down else -1
    return "".join(rows)
```

---

#### 注意事项：
- 当 `numRows = 1` 时，直接返回原字符串。
- 注意 `going_down` 标志的切换时机（在 `current_row = 0` 或 `current_row = numRows - 1` 时切换方向）。

---

#### 代码实现（Python，模拟法）：
```python
def convert(s: str, numRows: int) -> str:
    if numRows == 1:
        return s
    rows = [""] * numRows
    current_row = 0
    going_down = False
    for c in s:
        rows[current_row] += c
        if current_row == 0 or current_row == numRows - 1:
            going_down = not going_down
        current_row += 1 if going_down else -1
    return "".join(rows)
```

---

#### 复杂度分析：
- **时间复杂度**：`O(n)`，遍历字符串一次。
- **空间复杂度**：`O(n)`，存储 `numRows` 个字符串。

---

#### 其他解法（数学规律法）：
```python
def convert(s: str, numRows: int) -> str:
    if numRows == 1:
        return s
    cycle = 2 * numRows - 2
    res = []
    for i in range(numRows):
        for j in range(i, len(s), cycle):
            res.append(s[j])
            if i != 0 and i != numRows - 1 and j + cycle - 2 * i < len(s):
                res.append(s[j + cycle - 2 * i])
    return "".join(res)
```