### 题目：7. 整数反转

#### 难度：中等

#### 题目描述：
给定一个 32 位有符号整数 `x`，返回其数字部分反转后的结果。如果反转后的整数超过 32 位有符号整数的范围 `[−2³¹, 2³¹ − 1]`，则返回 `0`。假设环境不允许存储 64 位整数（有符号或无符号）。

---

#### 示例：

**示例 1**：
- 输入：`x = 123`
- 输出：`321`

**示例 2**：
- 输入：`x = -123`
- 输出：`-321`

**示例 3**：
- 输入：`x = 120`
- 输出：`21`

**示例 4**：
- 输入：`x = 0`
- 输出：`0`

---

#### 提示：
- `-2³¹ <= x <= 2³¹ - 1`

---

#### 解题思路：
1. **数学方法**：
   - 通过循环取余和除法操作，逐步反转整数。
   - 在反转过程中，检查是否溢出（即是否超出 `[−2³¹, 2³¹ − 1]` 范围）。
   - 时间复杂度：`O(log |x|)`（取决于 `x` 的位数）。
   - 空间复杂度：`O(1)`。

2. **字符串反转法**（不推荐）：
   - 将整数转为字符串，反转后再转回整数。
   - 需要处理前导零和符号，且效率较低。

---

#### 伪代码（数学方法）：
```
function reverse(x):
    rev = 0
    sign = 1 if x > 0 else -1
    x = abs(x)
    while x != 0:
        pop = x % 10
        x = x // 10
        # 检查是否溢出
        if rev > (2³¹ - 1) // 10 or (rev == (2³¹ - 1) // 10 and pop > 7):
            return 0
        if rev < -2³¹ // 10 or (rev == -2³¹ // 10 and pop < -8):
            return 0
        rev = rev * 10 + pop
    return sign * rev
```

---

#### 注意事项：
- 处理负数时，先取绝对值，最后恢复符号。
- 检查溢出时，需要提前判断 `rev` 是否会在下一步操作中超出范围。
- 32 位有符号整数的范围是 `[−2³¹, 2³¹ − 1]`，即 `[-2147483648, 2147483647]`。

---

#### 代码实现（Python，数学方法）：
```python
def reverse(x: int) -> int:
    rev = 0
    sign = 1 if x > 0 else -1
    x = abs(x)
    while x != 0:
        pop = x % 10
        x = x // 10
        # 检查是否溢出
        if rev > (2**31 - 1) // 10 or (rev == (2**31 - 1) // 10 and pop > 7):
            return 0
        if rev < -2**31 // 10 or (rev == -2**31 // 10 and pop < -8):
            return 0
        rev = rev * 10 + pop
    return sign * rev
```

---

#### 复杂度分析：
- **时间复杂度**：`O(log |x|)`，因为每次循环 `x` 都会减少一位。
- **空间复杂度**：`O(1)`，仅使用常数空间。

---

#### 其他解法（字符串反转法）：
```python
def reverse(x: int) -> int:
    sign = -1 if x < 0 else 1
    rev = int(str(abs(x))[::-1]) * sign
    return rev if -2**31 <= rev <= 2**31 - 1 else 0
```

虽然字符串反转法代码简洁，但在处理大整数时效率较低，且不符合题目中“不允许存储 64 位整数”的限制。因此，数学方法更为推荐。