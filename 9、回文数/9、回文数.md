### 题目：9. 回文数

#### 难度：简单

#### 题目描述：
给定一个整数 `x`，判断它是否是回文数。回文数是指正序和倒序读都相同的整数。

**示例**：
- `121` 是回文数。
- `-121` 不是回文数（因为 `-121` 倒序是 `121-`）。
- `10` 不是回文数（因为 `10` 倒序是 `01`）。

---

#### 示例：

**示例 1**：
- 输入：`x = 121`
- 输出：`true`

**示例 2**：
- 输入：`x = -121`
- 输出：`false`

**示例 3**：
- 输入：`x = 10`
- 输出：`false`

---

#### 提示：
- `-2³¹ <= x <= 2³¹ - 1`

---

#### 解题思路：
1. **字符串反转法**：
   - 将整数转为字符串，判断字符串是否与其反转相同。
   - 时间复杂度：`O(n)`（`n` 为数字位数），空间复杂度：`O(n)`。

2. **数学方法（不转字符串）**：
   - 反转数字的后半部分，与前半部分比较。
   - 关键点：
     - 负数直接返回 `false`。
     - 反转时只需反转一半的数字即可。
   - 时间复杂度：`O(log n)`，空间复杂度：`O(1)`。

---

#### 伪代码（数学方法）：
```
function isPalindrome(x):
    if x < 0 or (x % 10 == 0 and x != 0):
        return False
    reversed_half = 0
    while x > reversed_half:
        reversed_half = reversed_half * 10 + x % 10
        x = x // 10
    return x == reversed_half or x == reversed_half // 10
```

---

#### 注意事项：
- 负数不可能是回文数（因为符号 `-` 无法对称）。
- 末尾为 `0` 的非零数（如 `10`）不可能是回文数（因为反转后首位不能为 `0`）。
- 反转时只需反转一半的数字即可（如 `1221`，反转后 `12` 和 `12` 比较）。

---

#### 代码实现（Python，数学方法）：
```python
def isPalindrome(x: int) -> bool:
    if x < 0 or (x % 10 == 0 and x != 0):
        return False
    reversed_half = 0
    while x > reversed_half:
        reversed_half = reversed_half * 10 + x % 10
        x = x // 10
    return x == reversed_half or x == reversed_half // 10
```

---

#### 复杂度分析：
- **时间复杂度**：`O(log n)`，每次循环 `x` 减少一位。
- **空间复杂度**：`O(1)`，仅使用常数空间。

---

#### 其他解法（字符串反转法）：
```python
def isPalindrome(x: int) -> bool:
    return str(x) == str(x)[::-1]
```

虽然字符串反转法代码简洁，但题目要求不转字符串的解法，因此数学方法更符合要求。